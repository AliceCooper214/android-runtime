package org.nativescript.staticbindinggenerator.files.impl;

import org.apache.bcel.classfile.ClassParser;
import org.apache.bcel.classfile.JavaClass;
import org.nativescript.staticbindinggenerator.Generator;
import org.nativescript.staticbindinggenerator.files.FileSystemHelper;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayDeque;
import java.util.HashMap;
import java.util.Map;
import java.util.jar.JarInputStream;
import java.util.zip.ZipEntry;

public class FileSystemHelperImpl implements FileSystemHelper {

    private static final String CLASS_EXT = ".class";

    private final boolean shouldThrowOnError;

    public FileSystemHelperImpl(boolean shouldThrowOnError) {
        this.shouldThrowOnError = shouldThrowOnError;
    }


    @Override
    public Map<String, JavaClass> readClassesFromJar(String jarPath) {
        Map<String, JavaClass> classes = new HashMap<String, JavaClass>();
        if(jarPath.contains("sbg")){
            int a = 5;
        }
        JarInputStream jis = null;
        try {
            String name = null;
            jis = new JarInputStream(new FileInputStream(jarPath));
            for (ZipEntry ze = jis.getNextEntry(); ze != null; ze = jis.getNextEntry()) {
                try {
                    name = ze.getName();
                    if (name.endsWith(CLASS_EXT)) {


                        if(name.contains("DerivedChild")){
                            System.out.println("!!!!! VM: " + jarPath);
                        }


                        name = name.substring(0, name.length() - CLASS_EXT.length()).replace('/', '.').replace('$', '.');
                        ClassParser cp = new ClassParser(jis, name);
                        JavaClass clazz = cp.parse();
                        classes.put(name, clazz);
                    }
                } catch (IOException e) {
                    if (shouldThrowOnError) {
                        throw new RuntimeException("Error while parsing class file!", e);
                    } else {
                        e.printStackTrace();
                    }
                }
            }
        } catch (IOException ioe) {
            if (shouldThrowOnError) {
                throw new RuntimeException("Error while reading JAR entry!", ioe);
            } else {
                ioe.printStackTrace();
            }
        } finally {
            if (jis != null) {
                try {
                    jis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return classes;
    }

    @Override
    public Map<String, JavaClass> readClassesFromDirectory(String directoryPath) {
        Map<String, JavaClass> classes = new HashMap<String, JavaClass>();
        if(directoryPath.contains("sbg")){
            int a = 5;
        }

        ArrayDeque<File> d = new ArrayDeque<File>();
        d.add(new File(directoryPath));

        while (!d.isEmpty()) {
            File cur = d.pollFirst();
            File[] files = cur.listFiles();
            for (File f : files) {
                if (f.isFile() && f.getName().endsWith(CLASS_EXT)) {
                    if(f.getName().contains("DerivedChild")){
                        System.out.println("!!!!! VM: " + f.getPath());
                    }

                    ClassParser cp = new ClassParser(f.getAbsolutePath());
                    JavaClass clazz = null;
                    try {
                        clazz = cp.parse();
                    } catch (IOException e) {
                        if (shouldThrowOnError) {
                            throw new RuntimeException("Error while parsing class file!", e);
                        } else {
                            e.printStackTrace();
                        }
                    }
                    String name = clazz.getClassName();
                    name = name.replace('/', '.').replace('$', '.');
                    classes.put(name, clazz);
                } else if (f.isDirectory()) {
                    d.addLast(f);
                }
            }
        }

        return classes;
    }

    @Override
    public void cleanPreviouslyAutoGeneratedSbgFiles(File folder) {
        // Recursively traverse all files in the output folder and
        // remove them if they were auto-generated from a previous run
        // of the static binding generator. This will ensure that if
        // some javascript files containing native extends are removed,
        // their corresponding java classes will also be removed.
        File[] files = folder.listFiles();
        for (File file : files) {
            if (file.isDirectory()) {
                cleanPreviouslyAutoGeneratedSbgFiles(file);
            } else if ("java".equalsIgnoreCase(getFileExtension(file.toString()))) {
                if (checkIfFileIsGeneratedByTheSbg(file)) {
                    file.delete();
                }
            }
        }
    }

    private String getFileExtension(String filename) {
        String extension = "";

        int i = filename.lastIndexOf('.');
        if (i > 0) {
            extension = filename.substring(i + 1);
        }

        return extension;
    }

    private boolean checkIfFileIsGeneratedByTheSbg(File file) {

        int counter = 0;
        int prologueLength = Generator.AUTO_GENERATED_FILE_PROLOGUE.length();
        StringBuilder sb = new StringBuilder();

        try {
            FileInputStream fis = new FileInputStream(file);
            while (fis.available() > 0 && counter < prologueLength) {
                sb.append((char) fis.read());
                counter += 1;
            }
        } catch (IOException e) {
            throw new RuntimeException("Error while reading the file!", e);
        }

        return sb.toString().equals(Generator.AUTO_GENERATED_FILE_PROLOGUE);
    }
}
