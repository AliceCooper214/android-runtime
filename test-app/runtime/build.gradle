apply plugin: 'com.android.library'

def optimized = project.hasProperty("optimized")
if (optimized) {
    println "Optimized build triggered."
}

def optimizedWithInspector = project.hasProperty("optimizedWithInspector")
if (optimizedWithInspector) {
    println "Optimized build with inspector triggered."
}

def onlyX86 = project.hasProperty("onlyX86")
if (onlyX86) {
    println "OnlyX86 build triggered."
}

def useCCache = project.hasProperty("useCCache")
if (useCCache) {
    println "Use CCache build triggered."
}


def hasNdkVersion = project.hasProperty("ndkVersion")
if (hasNdkVersion) {
    println "Runtime using NDK version " + ndkVersion
}

def NDK_PATH =  System.getenv("ANDROID_NDK") ?: System.getenv("ANDROID_NDK_ROOT")

android {

    compileSdkVersion COMPILE_SDK_VERSION as int
    buildToolsVersion BUILD_TOOLS_VERSION as String

    sourceSets {
        main {
            def defaultSrcPath = "src/main/java"
            def bindingGeneratorSourcePath = new File(project(":runtime-binding-generator").projectDir, defaultSrcPath)

            // embed runtime binding generator in runtime, while keeping it in a separate project
            java.srcDirs = [bindingGeneratorSourcePath, defaultSrcPath]
        }
    }

    if (hasNdkVersion) {
        ndkVersion ndkVersion
    }

    defaultConfig {
        minSdkVersion MIN_SDK_VERSION as int
        targetSdkVersion COMPILE_SDK_VERSION as int

        if (!optimized && !optimizedWithInspector) {
            project.archivesBaseName = "${archivesBaseName}-regular"
        } else {
            if (optimized) {
                project.archivesBaseName = "${archivesBaseName}-optimized"
            } else if (optimizedWithInspector) {
                project.archivesBaseName = "${archivesBaseName}-optimized-with-inspector"
            }
        }

        externalNativeBuild {
            ndkBuild {
                arguments.add("NDK_APPLICATION_MK=$projectDir/src/main/jni/Application.mk")
                if (optimized) {
                    arguments.add("-DOPTIMIZED_BUILD=true")
                }

                if (optimizedWithInspector) {
                    arguments.add("-DOPTIMIZED_WITH_INSPECTOR_BUILD=true")
                }

                if (useCCache) {
                    arguments.add("-DUSE_CCACHE=true")
                }

                arguments "-DANDROID_TOOLCHAIN=clang", "-DANDROID_STL=c++_static", "-DANDROID_NDK_ROOT=${NDK_PATH}"
            }
        }

        ndk {
            minSdkVersion MIN_SDK_VERSION as int
            if (onlyX86) {
                abiFilters 'x86'
            } else {
                abiFilters 'x86', 'x86_64', 'armeabi-v7a', 'arm64-v8a'
            }
        }
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
    externalNativeBuild {
        ndkBuild {
            path "src/main/jni/nativescript/jni/Android.mk"
        }
    }
}

allprojects {
    gradle.projectsEvaluated {
        tasks.withType(JavaCompile) {
            options.compilerArgs << "-Xlint:all" << "-Werror"
        }
    }
}

dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    testImplementation 'junit:junit:4.13.2'
    testImplementation 'org.mockito:mockito-core:3.0.0'
}

tasks.whenTaskAdded { task ->
    def taskName = task.getName()
    if (taskName.contains("externalNativeBuildRelease")) {
        setRuntimeCommit.dependsOn(setPackageVersion)
        task.dependsOn(setRuntimeCommit)
    }

    if (taskName.contains("bundleReleaseAar")) {
        task.dependsOn("testDebugUnitTest")
    }

    if (taskName.contains("Strip")) {
        task.finalizedBy(revertVersionFile)
    }
    if ((taskName == "bundleDebug") || (taskName == "bundleRelease")) {
        task.finalizedBy createPackageConfigFileTask(taskName)
    }
}

task setPackageVersion {
    onlyIf {
        project.hasProperty('packageVersion')
    }

    doFirst {
        println "Setting runtime version: '${packageVersion}'"

        def versionFile = "$projectDir/src/main/cpp/Version.h"
        String contents = new File(versionFile).getText("UTF-8")
        contents = contents.replaceAll(/0.0.0.0/, packageVersion)
        new File(versionFile).write(contents, "UTF-8")
    }
}

task setRuntimeCommit {
    onlyIf {
        project.hasProperty('gitCommitVersion')
    }

    doFirst {
        println "Setting runtime commit: '${gitCommitVersion}'"

        def versionFile = "$projectDir/src/main/cpp/Version.h"
        String contents = new File(versionFile).getText("UTF-8")
        contents = contents.replaceAll(/RUNTIME_COMMIT_SHA_PLACEHOLDER/, gitCommitVersion)
        new File(versionFile).write(contents, "UTF-8")
    }
}

task revertVersionFile(type: Exec) {
    onlyIf {
        project.hasProperty('packageVersion') || project.hasProperty('gitCommitVersion')
    }

    doFirst {
        def isWinOs = System.properties['os.name'].toLowerCase().contains('windows')
        def versionFileName = "$projectDir/src/main/cpp/Version.h"
        def versionFilePath = new File(versionFileName).getAbsolutePath()
        println "Reverting Version.h file: ${versionFilePath}"

        if (isWinOs) {
            commandLine "cmd", "/c", "git", "checkout", "--", versionFilePath
        } else {
            commandLine "git", "checkout", "--", versionFilePath
        }
    }
}
repositories {
    mavenCentral()
}

def createPackageConfigFileTask(taskName) {
    def mode = (taskName == "bundleDebug") ? "debug" : "release"

    return tasks.create(name: "packageConfigFileTaskFor${mode}",) {
        def sdkDir = android.getSdkDirectory().getAbsolutePath()
        doFirst {
            def pathToAAR = "${buildDir}/outputs/aar/${project.archivesBaseName}-${mode}.aar"

            if (new File(pathToAAR).exists()) {
                def isWinOs = System.properties['os.name'].toLowerCase().contains('windows')

                def aaptCommand = new File(sdkDir, "/build-tools/$project.ext._buildToolsVersion/aapt").getAbsolutePath()
                if (isWinOs) {
                    aaptCommand += ".exe"
                }

                def removeCmdParams = new ArrayList<String>([aaptCommand, "remove", pathToAAR, "config.json"])
                exec {
                    ignoreExitValue true
                    workingDir "$projectDir/src/main"
                    commandLine removeCmdParams.toArray()
                }
                def addCmdParams = new ArrayList<String>([aaptCommand, "add", pathToAAR, "config.json"])
                exec {
                    workingDir "$projectDir/src/main"
                    commandLine addCmdParams.toArray()
                }
            }
        }
    }
}